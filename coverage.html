
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>goDNS: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">dklbreitling/goDNS/cmd/goDNS/main.go (0.0%)</option>
				
				<option value="file1">dklbreitling/goDNS/internal/config/config.go (84.0%)</option>
				
				<option value="file2">dklbreitling/goDNS/pkg/client/client.go (3.1%)</option>
				
				<option value="file3">dklbreitling/goDNS/pkg/dns/labels.go (91.4%)</option>
				
				<option value="file4">dklbreitling/goDNS/pkg/dns/message.go (50.0%)</option>
				
				<option value="file5">dklbreitling/goDNS/pkg/dns/types.go (56.7%)</option>
				
				<option value="file6">dklbreitling/goDNS/pkg/records/a.go (100.0%)</option>
				
				<option value="file7">dklbreitling/goDNS/pkg/records/aaaa.go (58.3%)</option>
				
				<option value="file8">dklbreitling/goDNS/pkg/records/generic.go (0.0%)</option>
				
				<option value="file9">dklbreitling/goDNS/pkg/records/ns.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Main package for the goDNS application
package main

import (
        "fmt"
        "log/slog"
        "os"

        "dklbreitling/goDNS/internal/config"
        "dklbreitling/goDNS/pkg/client"
        "dklbreitling/goDNS/pkg/dns"
)

// main is the entry point for the goDNS application
func main() <span class="cov0" title="0">{
        logger := slog.New(slog.NewTextHandler(os.Stderr, nil))
        cfg := config.DefaultConfig()

        if len(os.Args) &lt; 2 </span><span class="cov0" title="0">{
                logger.Error("Usage: goDNS &lt;domain&gt;")
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">domain := os.Args[1]
        
        // Create DNS client
        dnsClient, err := client.New(cfg, logger)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("Failed to create DNS client", "error", err)
                os.Exit(1)
        }</span>

        // Query for A records
        <span class="cov0" title="0">result, err := dnsClient.Query(domain, dns.TypeA)
        if err != nil </span><span class="cov0" title="0">{
                logger.Error("DNS query failed", "error", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">fmt.Println("DNS Query Result:\n", result.String())</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Package config handles configuration for the DNS client
package config

import (
        "fmt"
        "net"
        "time"
)

// Config holds the DNS client configuration
type Config struct {
        // Network settings
        NameServer string        // DNS server address (host:port)
        Protocol   string        // "udp" or "tcp"
        Timeout    time.Duration // Query timeout

        // Query settings
        RecursionDesired bool // Set RD bit in queries
        RetryCount       int  // Number of retries on failure

        // Debug settings
        Debug     bool   // Enable debug output
        DumpFiles bool   // Enable hex dump files
        LogLevel  string // Log level (debug, info, warn, error)
}

// DefaultConfig returns a configuration with sensible defaults
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                NameServer:       "198.41.0.4:53", // Root server A
                Protocol:         "udp",
                Timeout:          5 * time.Second,
                RecursionDesired: true,
                RetryCount:       3,
                Debug:            false,
                DumpFiles:        false,
                LogLevel:         "info",
        }
}</span>

// Validate checks if the configuration is valid
func (c *Config) Validate() error <span class="cov8" title="1">{
        // Validate name server
        if c.NameServer == "" </span><span class="cov8" title="1">{
                return fmt.Errorf("name server cannot be empty")
        }</span>
        
        <span class="cov8" title="1">host, port, err := net.SplitHostPort(c.NameServer)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid name server format: %w", err)
        }</span>
        
        <span class="cov8" title="1">if net.ParseIP(host) == nil </span><span class="cov0" title="0">{
                // Try to resolve hostname
                if _, err := net.ResolveIPAddr("ip", host); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("cannot resolve name server hostname %s: %w", host, err)
                }</span>
        }
        
        <span class="cov8" title="1">if port == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("name server port is required")
        }</span>
        
        // Validate protocol
        <span class="cov8" title="1">if c.Protocol != "udp" &amp;&amp; c.Protocol != "tcp" </span><span class="cov8" title="1">{
                return fmt.Errorf("protocol must be 'udp' or 'tcp', got '%s'", c.Protocol)
        }</span>
        
        // Validate timeout
        <span class="cov8" title="1">if c.Timeout &lt;= 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("timeout must be positive, got %v", c.Timeout)
        }</span>
        
        // Validate retry count
        <span class="cov8" title="1">if c.RetryCount &lt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("retry count cannot be negative, got %d", c.RetryCount)
        }</span>
        
        // Validate log level
        <span class="cov8" title="1">validLevels := map[string]bool{
                "debug": true,
                "info":  true,
                "warn":  true,
                "error": true,
        }
        if !validLevels[c.LogLevel] </span><span class="cov8" title="1">{
                return fmt.Errorf("invalid log level '%s', must be one of: debug, info, warn, error", c.LogLevel)
        }</span>
        
        <span class="cov8" title="1">return nil</span>
}

// GetMaxMessageSize returns the maximum message size for the configured protocol
func (c *Config) GetMaxMessageSize() int <span class="cov8" title="1">{
        switch c.Protocol </span>{
        case "tcp":<span class="cov8" title="1">
                return 65535</span> // Theoretical maximum for TCP
        case "udp":<span class="cov8" title="1">
                return 512</span> // RFC 1035 limit for UDP
        default:<span class="cov8" title="1">
                return 512</span> // Safe default
        }
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Package client provides a DNS client implementation
package client

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "log/slog"
        "math/rand"
        "net"
        "time"

        "dklbreitling/goDNS/internal/config"
        "dklbreitling/goDNS/pkg/dns"
        "dklbreitling/goDNS/pkg/records"
)

// Client represents a DNS client
type Client struct {
        config *config.Config
        logger *slog.Logger
}

// New creates a new DNS client with the given configuration
func New(cfg *config.Config, logger *slog.Logger) (*Client, error) <span class="cov8" title="1">{
        if err := cfg.Validate(); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>
        
        <span class="cov8" title="1">return &amp;Client{
                config: cfg,
                logger: logger,
        }, nil</span>
}

// Query performs a DNS query for the given domain and record type
func (c *Client) Query(domain string, qtype dns.QType) (*dns.Message, error) <span class="cov8" title="1">{
        // Validate domain
        if err := dns.ValidateDomain(domain); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid domain: %w", err)
        }</span>
        
        // Build query message
        <span class="cov0" title="0">query, err := c.buildQuery(domain, qtype)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to build query: %w", err)
        }</span>
        
        // Send query and receive response
        <span class="cov0" title="0">response, err := c.sendQuery(query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send query: %w", err)
        }</span>
        
        <span class="cov0" title="0">return response, nil</span>
}

// buildQuery creates a DNS query message
func (c *Client) buildQuery(domain string, qtype dns.QType) (*dns.Message, error) <span class="cov0" title="0">{
        // Generate random query ID
        queryID := uint16(rand.Intn(65536))
        
        // Build header
        flags := dns.HeaderQRQuery | dns.HeaderOpcodeQuery
        if c.config.RecursionDesired </span><span class="cov0" title="0">{
                flags |= dns.HeaderRD
        }</span>
        
        <span class="cov0" title="0">header := dns.Header{
                ID:      queryID,
                Flags:   flags,
                QDCount: 1,
                ANCount: 0,
                NSCount: 0,
                ARCount: 0,
        }
        
        // Build question
        question := dns.Question{
                Name:  dns.StringToLabels(domain),
                Type:  qtype,
                Class: dns.ClassIN,
        }
        
        return &amp;dns.Message{
                Header:     header,
                Question:   []dns.Question{question},
                Answer:     nil,
                Authority:  nil,
                Additional: nil,
        }, nil</span>
}

// sendQuery sends a DNS query and returns the response
func (c *Client) sendQuery(query *dns.Message) (*dns.Message, error) <span class="cov0" title="0">{
        // Convert query to bytes
        queryBytes, err := query.ToBytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to serialize query: %w", err)
        }</span>
        
        // Add TCP length prefix if needed
        <span class="cov0" title="0">if c.config.Protocol == "tcp" </span><span class="cov0" title="0">{
                length := uint16(len(queryBytes))
                buf := new(bytes.Buffer)
                if err := binary.Write(buf, binary.BigEndian, length); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to add TCP length prefix: %w", err)
                }</span>
                <span class="cov0" title="0">queryBytes = append(buf.Bytes(), queryBytes...)</span>
        }
        
        <span class="cov0" title="0">c.logger.Debug("Sending DNS query", "size", len(queryBytes), "protocol", c.config.Protocol)
        
        // Connect to DNS server
        conn, err := net.DialTimeout(c.config.Protocol, c.config.NameServer, c.config.Timeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to DNS server: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        
        // Set write deadline
        if err := conn.SetWriteDeadline(time.Now().Add(c.config.Timeout)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set write deadline: %w", err)
        }</span>
        
        // Send query
        <span class="cov0" title="0">n, err := conn.Write(queryBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write query: %w", err)
        }</span>
        <span class="cov0" title="0">if n != len(queryBytes) </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("incomplete write: wrote %d bytes, expected %d", n, len(queryBytes))
        }</span>
        
        // Set read deadline
        <span class="cov0" title="0">if err := conn.SetReadDeadline(time.Now().Add(c.config.Timeout)); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to set read deadline: %w", err)
        }</span>
        
        // Read response
        <span class="cov0" title="0">responseBytes := make([]byte, c.config.GetMaxMessageSize())
        n, err = conn.Read(responseBytes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read response: %w", err)
        }</span>
        <span class="cov0" title="0">responseBytes = responseBytes[:n]
        
        c.logger.Debug("Received DNS response", "size", n)
        
        // Parse response
        response, err := c.parseResponse(responseBytes, query.Header.ID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse response: %w", err)
        }</span>
        
        <span class="cov0" title="0">return response, nil</span>
}

// parseResponse parses a DNS response from wire format
func (c *Client) parseResponse(data []byte, expectedID uint16) (*dns.Message, error) <span class="cov0" title="0">{
        // Handle TCP length prefix
        if c.config.Protocol == "tcp" </span><span class="cov0" title="0">{
                if len(data) &lt; 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("TCP response too short for length prefix")
                }</span>
                <span class="cov0" title="0">length := binary.BigEndian.Uint16(data[:2])
                if int(length) != len(data)-2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("TCP length mismatch: expected %d, got %d", length, len(data)-2)
                }</span>
                <span class="cov0" title="0">data = data[2:]</span> // Remove length prefix
        }
        
        <span class="cov0" title="0">if len(data) &lt; 12 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("DNS response too short: %d bytes", len(data))
        }</span>
        
        <span class="cov0" title="0">index := 0
        
        // Parse header
        header := dns.Header{
                ID:      binary.BigEndian.Uint16(data[index : index+2]),
                Flags:   dns.HeaderBitfield(binary.BigEndian.Uint16(data[index+2 : index+4])),
                QDCount: binary.BigEndian.Uint16(data[index+4 : index+6]),
                ANCount: binary.BigEndian.Uint16(data[index+6 : index+8]),
                NSCount: binary.BigEndian.Uint16(data[index+8 : index+10]),
                ARCount: binary.BigEndian.Uint16(data[index+10 : index+12]),
        }
        index += 12
        
        // Verify query ID matches
        if header.ID != expectedID </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("response ID %d does not match query ID %d", header.ID, expectedID)
        }</span>
        
        <span class="cov0" title="0">message := &amp;dns.Message{
                Header:     header,
                Question:   make([]dns.Question, header.QDCount),
                Answer:     make([]dns.ResourceRecord, header.ANCount),
                Authority:  make([]dns.ResourceRecord, header.NSCount),
                Additional: make([]dns.ResourceRecord, header.ARCount),
        }
        
        // Parse questions (should match what we sent)
        for i := uint16(0); i &lt; header.QDCount; i++ </span><span class="cov0" title="0">{
                question, newIndex, err := c.parseQuestion(data, index)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse question %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">message.Question[i] = question
                index = newIndex</span>
        }
        
        // Parse answer records
        <span class="cov0" title="0">for i := uint16(0); i &lt; header.ANCount; i++ </span><span class="cov0" title="0">{
                rr, newIndex, err := c.parseResourceRecord(data, index)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse answer record %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">message.Answer[i] = rr
                index = newIndex</span>
        }
        
        // Parse authority records
        <span class="cov0" title="0">for i := uint16(0); i &lt; header.NSCount; i++ </span><span class="cov0" title="0">{
                rr, newIndex, err := c.parseResourceRecord(data, index)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse authority record %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">message.Authority[i] = rr
                index = newIndex</span>
        }
        
        // Parse additional records
        <span class="cov0" title="0">for i := uint16(0); i &lt; header.ARCount; i++ </span><span class="cov0" title="0">{
                rr, newIndex, err := c.parseResourceRecord(data, index)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to parse additional record %d: %w", i, err)
                }</span>
                <span class="cov0" title="0">message.Additional[i] = rr
                index = newIndex</span>
        }
        
        <span class="cov0" title="0">return message, nil</span>
}

// parseQuestion parses a DNS question from wire format
func (c *Client) parseQuestion(data []byte, index int) (dns.Question, int, error) <span class="cov0" title="0">{
        // Parse name labels
        labels, newIndex, err := c.parseLabels(data, index)
        if err != nil </span><span class="cov0" title="0">{
                return dns.Question{}, 0, fmt.Errorf("failed to parse question name: %w", err)
        }</span>
        
        <span class="cov0" title="0">if newIndex+4 &gt; len(data) </span><span class="cov0" title="0">{
                return dns.Question{}, 0, fmt.Errorf("question data truncated")
        }</span>
        
        <span class="cov0" title="0">qtype := dns.QType(binary.BigEndian.Uint16(data[newIndex : newIndex+2]))
        qclass := dns.QClass(binary.BigEndian.Uint16(data[newIndex+2 : newIndex+4]))
        
        return dns.Question{
                Name:  labels,
                Type:  qtype,
                Class: qclass,
        }, newIndex + 4, nil</span>
}

// parseResourceRecord parses a DNS resource record from wire format
func (c *Client) parseResourceRecord(data []byte, index int) (dns.ResourceRecord, int, error) <span class="cov0" title="0">{
        // Parse name labels
        labels, newIndex, err := c.parseLabels(data, index)
        if err != nil </span><span class="cov0" title="0">{
                return dns.ResourceRecord{}, 0, fmt.Errorf("failed to parse RR name: %w", err)
        }</span>
        
        <span class="cov0" title="0">if newIndex+10 &gt; len(data) </span><span class="cov0" title="0">{
                return dns.ResourceRecord{}, 0, fmt.Errorf("RR header data truncated")
        }</span>
        
        <span class="cov0" title="0">rrType := dns.QType(binary.BigEndian.Uint16(data[newIndex : newIndex+2]))
        rrClass := dns.QClass(binary.BigEndian.Uint16(data[newIndex+2 : newIndex+4]))
        ttl := int32(binary.BigEndian.Uint32(data[newIndex+4 : newIndex+8]))
        rdLength := binary.BigEndian.Uint16(data[newIndex+8 : newIndex+10])
        newIndex += 10
        
        if newIndex+int(rdLength) &gt; len(data) </span><span class="cov0" title="0">{
                return dns.ResourceRecord{}, 0, fmt.Errorf("RR data truncated")
        }</span>
        
        // Parse resource data based on type
        <span class="cov0" title="0">var rdata dns.ResourceData
        rdataBytes := data[newIndex : newIndex+int(rdLength)]
        
        switch rrType </span>{
        case dns.TypeA:<span class="cov0" title="0">
                if len(rdataBytes) != 4 </span><span class="cov0" title="0">{
                        return dns.ResourceRecord{}, 0, fmt.Errorf("invalid A record length: %d", len(rdataBytes))
                }</span>
                <span class="cov0" title="0">ip := net.IPv4(rdataBytes[0], rdataBytes[1], rdataBytes[2], rdataBytes[3])
                if aRecord, err := records.NewARecord(ip); err == nil </span><span class="cov0" title="0">{
                        rdata = aRecord
                }</span> else<span class="cov0" title="0"> {
                        rdata = records.NewGenericRecord(rrType, rdataBytes)
                }</span>
        case dns.TypeAAAA:<span class="cov0" title="0">
                if len(rdataBytes) != 16 </span><span class="cov0" title="0">{
                        return dns.ResourceRecord{}, 0, fmt.Errorf("invalid AAAA record length: %d", len(rdataBytes))
                }</span>
                <span class="cov0" title="0">ip := net.IP(rdataBytes)
                if aaaaRecord, err := records.NewAAAARecord(ip); err == nil </span><span class="cov0" title="0">{
                        rdata = aaaaRecord
                }</span> else<span class="cov0" title="0"> {
                        rdata = records.NewGenericRecord(rrType, rdataBytes)
                }</span>
        case dns.TypeNS:<span class="cov0" title="0">
                nsLabels, _, err := c.parseLabels(data, newIndex)
                if err != nil </span><span class="cov0" title="0">{
                        rdata = records.NewGenericRecord(rrType, rdataBytes)
                }</span> else<span class="cov0" title="0"> {
                        rdata = records.NewNSRecord(nsLabels)
                }</span>
        default:<span class="cov0" title="0">
                rdata = records.NewGenericRecord(rrType, rdataBytes)</span>
        }
        
        <span class="cov0" title="0">return dns.ResourceRecord{
                Name:     labels,
                Type:     rrType,
                Class:    rrClass,
                TTL:      ttl,
                RDLength: rdLength,
                RData:    rdata,
        }, newIndex + int(rdLength), nil</span>
}

// parseLabels parses DNS labels from wire format, handling compression
func (c *Client) parseLabels(data []byte, index int) ([]dns.Label, int, error) <span class="cov0" title="0">{
        var labels []dns.Label
        originalIndex := index
        followed := false
        
        for index &lt; len(data) </span><span class="cov0" title="0">{
                length := data[index]
                
                // Check for compression pointer
                if length&amp;0xC0 == 0xC0 </span><span class="cov0" title="0">{
                        if index+1 &gt;= len(data) </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("compression pointer truncated")
                        }</span>
                        <span class="cov0" title="0">pointer := int(binary.BigEndian.Uint16(data[index:index+2]) &amp; 0x3FFF)
                        if pointer &gt;= len(data) </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("invalid compression pointer: %d", pointer)
                        }</span>
                        
                        // Follow the pointer recursively
                        <span class="cov0" title="0">compressedLabels, _, err := c.parseLabels(data, pointer)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, 0, fmt.Errorf("failed to follow compression pointer: %w", err)
                        }</span>
                        <span class="cov0" title="0">labels = append(labels, compressedLabels...)
                        
                        if !followed </span><span class="cov0" title="0">{
                                return labels, index + 2, nil
                        }</span>
                        <span class="cov0" title="0">return labels, originalIndex + 2, nil</span>
                }
                
                // Regular label
                <span class="cov0" title="0">if length == 0 </span><span class="cov0" title="0">{
                        // Null terminator
                        labels = append(labels, dns.Label{Length: 0, Data: nil})
                        if !followed </span><span class="cov0" title="0">{
                                return labels, index + 1, nil
                        }</span>
                        <span class="cov0" title="0">return labels, originalIndex + 1, nil</span>
                }
                
                <span class="cov0" title="0">if index+1+int(length) &gt; len(data) </span><span class="cov0" title="0">{
                        return nil, 0, fmt.Errorf("label data truncated")
                }</span>
                
                <span class="cov0" title="0">label := dns.Label{
                        Length: length,
                        Data:   make([]byte, length),
                }
                copy(label.Data, data[index+1:index+1+int(length)])
                labels = append(labels, label)
                
                index += 1 + int(length)</span>
        }
        
        <span class="cov0" title="0">return nil, 0, fmt.Errorf("labels not properly terminated")</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package dns

import (
        "regexp"
        "strings"
)

// StringToLabels converts a domain name string to DNS labels
func StringToLabels(domain string) []Label <span class="cov8" title="1">{
        // Remove trailing dot if present
        domain = strings.TrimSuffix(domain, ".")
        
        if domain == "" </span><span class="cov8" title="1">{
                return []Label{{Length: 0, Data: nil}}
        }</span>
        
        <span class="cov8" title="1">parts := strings.Split(domain, ".")
        labels := make([]Label, len(parts)+1)
        
        for i, part := range parts </span><span class="cov8" title="1">{
                labels[i] = Label{
                        Length: byte(len(part)),
                        Data:   []byte(part),
                }
        }</span>
        
        // Add null terminator
        <span class="cov8" title="1">labels[len(parts)] = Label{Length: 0, Data: nil}
        
        return labels</span>
}

// LabelsToString converts DNS labels to a domain name string
func LabelsToString(labels []Label) string <span class="cov8" title="1">{
        if len(labels) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        
        <span class="cov8" title="1">var parts []string
        for _, label := range labels </span><span class="cov8" title="1">{
                if label.Length == 0 </span><span class="cov8" title="1">{
                        break</span> // Null terminator
                }
                <span class="cov8" title="1">parts = append(parts, string(label.Data))</span>
        }
        
        <span class="cov8" title="1">return strings.Join(parts, ".")</span>
}

// ValidateDomain validates a domain name according to RFC standards
func ValidateDomain(domain string) error <span class="cov8" title="1">{
        if len(domain) == 0 </span><span class="cov8" title="1">{
                return &amp;DomainError{Domain: domain, Reason: "domain cannot be empty"}
        }</span>
        
        <span class="cov8" title="1">if len(domain) &gt; 253 </span><span class="cov0" title="0">{
                return &amp;DomainError{Domain: domain, Reason: "domain too long (max 253 characters)"}
        }</span>
        
        // Remove trailing dot if present
        <span class="cov8" title="1">domain = strings.TrimSuffix(domain, ".")
        
        // Check each label
        labels := strings.Split(domain, ".")
        if len(labels) &lt; 1 </span><span class="cov0" title="0">{
                return &amp;DomainError{Domain: domain, Reason: "domain must have at least one label"}
        }</span>
        
        <span class="cov8" title="1">labelRegex := regexp.MustCompile(`^[a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?$`)
        
        for _, label := range labels </span><span class="cov8" title="1">{
                if len(label) == 0 </span><span class="cov8" title="1">{
                        return &amp;DomainError{Domain: domain, Reason: "empty label not allowed"}
                }</span>
                <span class="cov8" title="1">if len(label) &gt; 63 </span><span class="cov0" title="0">{
                        return &amp;DomainError{Domain: domain, Reason: "label too long (max 63 characters)"}
                }</span>
                <span class="cov8" title="1">if !labelRegex.MatchString(label) </span><span class="cov8" title="1">{
                        return &amp;DomainError{Domain: domain, Reason: "invalid characters in label: " + label}
                }</span>
        }
        
        <span class="cov8" title="1">return nil</span>
}

// DomainError represents a domain validation error
type DomainError struct {
        Domain string
        Reason string
}

func (e *DomainError) Error() string <span class="cov8" title="1">{
        return "invalid domain '" + e.Domain + "': " + e.Reason
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package dns

import (
        "bytes"
        "encoding/binary"
        "fmt"
)

// Message represents a complete DNS message according to RFC 1035
type Message struct {
        Header     Header
        Question   []Question
        Answer     []ResourceRecord
        Authority  []ResourceRecord
        Additional []ResourceRecord
}

// Header represents the DNS message header according to RFC 1035 Section 4.1.1
type Header struct {
        ID      uint16         // Query identifier
        Flags   HeaderBitfield // Flags and codes
        QDCount uint16         // Number of questions
        ANCount uint16         // Number of answer RRs
        NSCount uint16         // Number of authority RRs
        ARCount uint16         // Number of additional RRs
}

// Question represents a DNS question according to RFC 1035 Section 4.1.2
type Question struct {
        Name  []Label // Domain name as sequence of labels
        Type  QType   // Query type
        Class QClass  // Query class
}

// Label represents a DNS label according to RFC 1035
type Label struct {
        Length byte
        Data   []byte
}

// ResourceRecord represents a DNS resource record according to RFC 1035 Section 4.1.3
type ResourceRecord struct {
        Name     []Label      // Domain name
        Type     QType        // RR type
        Class    QClass       // RR class
        TTL      int32        // Time to live
        RDLength uint16       // Resource data length
        RData    ResourceData // Resource data
}

// ResourceData interface for different types of DNS record data
type ResourceData interface {
        Bytes() []byte
        String() string
        Type() QType
}

// ToBytes converts the DNS message to wire format
func (m *Message) ToBytes() ([]byte, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)

        // Write header
        headerBytes, err := m.Header.toBytes()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to serialize header: %w", err)
        }</span>
        <span class="cov8" title="1">buf.Write(headerBytes)

        // Write questions
        for _, q := range m.Question </span><span class="cov8" title="1">{
                qBytes, err := q.toBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to serialize question: %w", err)
                }</span>
                <span class="cov8" title="1">buf.Write(qBytes)</span>
        }

        // Write answer RRs
        <span class="cov8" title="1">for _, rr := range m.Answer </span><span class="cov0" title="0">{
                rrBytes, err := rr.toBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to serialize answer RR: %w", err)
                }</span>
                <span class="cov0" title="0">buf.Write(rrBytes)</span>
        }

        // Write authority RRs
        <span class="cov8" title="1">for _, rr := range m.Authority </span><span class="cov0" title="0">{
                rrBytes, err := rr.toBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to serialize authority RR: %w", err)
                }</span>
                <span class="cov0" title="0">buf.Write(rrBytes)</span>
        }

        // Write additional RRs
        <span class="cov8" title="1">for _, rr := range m.Additional </span><span class="cov0" title="0">{
                rrBytes, err := rr.toBytes()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to serialize additional RR: %w", err)
                }</span>
                <span class="cov0" title="0">buf.Write(rrBytes)</span>
        }

        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// String returns a human-readable representation of the DNS message
func (m *Message) String() string <span class="cov8" title="1">{
        var buf bytes.Buffer
        
        buf.WriteString("; DNS Message\n")
        buf.WriteString("; Header:\n")
        buf.WriteString(m.Header.String())
        
        if m.Header.QDCount &gt; 0 </span><span class="cov8" title="1">{
                buf.WriteString("\n; Question:\n")
                for _, q := range m.Question </span><span class="cov8" title="1">{
                        buf.WriteString(q.String())
                        buf.WriteString("\n")
                }</span>
        }
        
        <span class="cov8" title="1">if m.Header.ANCount &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString("\n; Answer:\n")
                for _, rr := range m.Answer </span><span class="cov0" title="0">{
                        buf.WriteString(rr.String())
                        buf.WriteString("\n")
                }</span>
        }
        
        <span class="cov8" title="1">if m.Header.NSCount &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString("\n; Authority:\n")
                for _, rr := range m.Authority </span><span class="cov0" title="0">{
                        buf.WriteString(rr.String())
                        buf.WriteString("\n")
                }</span>
        }
        
        <span class="cov8" title="1">if m.Header.ARCount &gt; 0 </span><span class="cov0" title="0">{
                buf.WriteString("\n; Additional:\n")
                for _, rr := range m.Additional </span><span class="cov0" title="0">{
                        buf.WriteString(rr.String())
                        buf.WriteString("\n")
                }</span>
        }
        
        <span class="cov8" title="1">return buf.String()</span>
}

// toBytes converts the header to wire format
func (h *Header) toBytes() ([]byte, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        
        fields := []interface{}{h.ID, h.Flags, h.QDCount, h.ANCount, h.NSCount, h.ARCount}
        for _, field := range fields </span><span class="cov8" title="1">{
                if err := binary.Write(buf, binary.BigEndian, field); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write header field: %w", err)
                }</span>
        }
        
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// String returns a human-readable representation of the header
func (h *Header) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("\tID: %04X\tFlags: %04X\tQDCount: %d\tANCount: %d\tNSCount: %d\tARCount: %d",
                h.ID, h.Flags, h.QDCount, h.ANCount, h.NSCount, h.ARCount)
}</span>

// toBytes converts the question to wire format
func (q *Question) toBytes() ([]byte, error) <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        
        // Write labels
        for _, label := range q.Name </span><span class="cov8" title="1">{
                buf.Write(label.ToBytes())
        }</span>
        
        // Write type and class
        <span class="cov8" title="1">if err := binary.Write(buf, binary.BigEndian, q.Type); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write question type: %w", err)
        }</span>
        <span class="cov8" title="1">if err := binary.Write(buf, binary.BigEndian, q.Class); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to write question class: %w", err)
        }</span>
        
        <span class="cov8" title="1">return buf.Bytes(), nil</span>
}

// String returns a human-readable representation of the question
func (q *Question) String() string <span class="cov8" title="1">{
        domain := LabelsToString(q.Name)
        return fmt.Sprintf("\t%s\t%s\t%s", domain, q.Type.String(), q.Class.String())
}</span>

// ToBytes converts the label to wire format
func (l *Label) ToBytes() []byte <span class="cov8" title="1">{
        return append([]byte{l.Length}, l.Data...)
}</span>

// toBytes converts the resource record to wire format
func (rr *ResourceRecord) toBytes() ([]byte, error) <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        
        // Write name labels
        for _, label := range rr.Name </span><span class="cov0" title="0">{
                buf.Write(label.ToBytes())
        }</span>
        
        // Write type, class, TTL, and RDLength
        <span class="cov0" title="0">fields := []interface{}{rr.Type, rr.Class, rr.TTL, rr.RDLength}
        for _, field := range fields </span><span class="cov0" title="0">{
                if err := binary.Write(buf, binary.BigEndian, field); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to write RR field: %w", err)
                }</span>
        }
        
        // Write resource data
        <span class="cov0" title="0">buf.Write(rr.RData.Bytes())
        
        return buf.Bytes(), nil</span>
}

// String returns a human-readable representation of the resource record
func (rr *ResourceRecord) String() string <span class="cov0" title="0">{
        domain := LabelsToString(rr.Name)
        return fmt.Sprintf("\t%s\t%s\t%s\tTTL: %d\t%s",
                domain, rr.Type.String(), rr.Class.String(), rr.TTL, rr.RData.String())
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">// Package dns provides DNS protocol types and constants according to RFC 1035
package dns

// QType represents DNS query types according to RFC 1035
type QType uint16

// QClass represents DNS query classes according to RFC 1035
type QClass uint16

// DNS Query Types - See RFC 1035 Section 3.2.2 and 3.2.3
const (
        TypeA     QType = 1  // A host address
        TypeNS    QType = 2  // An authoritative name server
        TypeMD    QType = 3  // A mail destination (Obsolete - use MX)
        TypeMF    QType = 4  // A mail forwarder (Obsolete - use MX)
        TypeCNAME QType = 5  // The canonical name for an alias
        TypeSOA   QType = 6  // Marks the start of a zone of authority
        TypeMB    QType = 7  // A mailbox domain name (EXPERIMENTAL)
        TypeMG    QType = 8  // A mail group member (EXPERIMENTAL)
        TypeMR    QType = 9  // A mail rename domain name (EXPERIMENTAL)
        TypeNULL  QType = 10 // A null RR (EXPERIMENTAL)
        TypeWKS   QType = 11 // A well known service description
        TypePTR   QType = 12 // A domain name pointer
        TypeHINFO QType = 13 // Host information
        TypeMINFO QType = 14 // Mailbox or mail list information
        TypeMX    QType = 15 // Mail exchange
        TypeTXT   QType = 16 // Text strings
        TypeAAAA  QType = 28 // IPv6 address (RFC 3596)
)

// DNS Query Types (QType only) - See RFC 1035 Section 3.2.3
const (
        TypeAXFR     QType = 252 // A request for a transfer of an entire zone
        TypeMAILB    QType = 253 // A request for mailbox-related records (MB, MG, or MR)
        TypeMAILA    QType = 254 // A request for mail agent RRs (Obsolete - see MX)
        TypeASTERISK QType = 255 // A request for all records
)

// DNS Classes - See RFC 1035 Section 3.2.4 and 3.2.5
const (
        ClassIN       QClass = 1   // The Internet
        ClassCS       QClass = 2   // The CSNET class (Obsolete)
        ClassCH       QClass = 3   // The CHAOS class
        ClassHS       QClass = 4   // Hesiod
        ClassASTERISK QClass = 255 // Any class
)

// String returns the string representation of a QType
func (qt QType) String() string <span class="cov8" title="1">{
        switch qt </span>{
        case TypeA:<span class="cov8" title="1">
                return "A"</span>
        case TypeNS:<span class="cov8" title="1">
                return "NS"</span>
        case TypeMD:<span class="cov0" title="0">
                return "MD"</span>
        case TypeMF:<span class="cov0" title="0">
                return "MF"</span>
        case TypeCNAME:<span class="cov8" title="1">
                return "CNAME"</span>
        case TypeSOA:<span class="cov8" title="1">
                return "SOA"</span>
        case TypeMB:<span class="cov0" title="0">
                return "MB"</span>
        case TypeMG:<span class="cov0" title="0">
                return "MG"</span>
        case TypeMR:<span class="cov0" title="0">
                return "MR"</span>
        case TypeNULL:<span class="cov0" title="0">
                return "NULL"</span>
        case TypeWKS:<span class="cov0" title="0">
                return "WKS"</span>
        case TypePTR:<span class="cov8" title="1">
                return "PTR"</span>
        case TypeHINFO:<span class="cov0" title="0">
                return "HINFO"</span>
        case TypeMINFO:<span class="cov0" title="0">
                return "MINFO"</span>
        case TypeMX:<span class="cov8" title="1">
                return "MX"</span>
        case TypeTXT:<span class="cov8" title="1">
                return "TXT"</span>
        case TypeAAAA:<span class="cov8" title="1">
                return "AAAA"</span>
        case TypeAXFR:<span class="cov0" title="0">
                return "AXFR"</span>
        case TypeMAILB:<span class="cov0" title="0">
                return "MAILB"</span>
        case TypeMAILA:<span class="cov0" title="0">
                return "MAILA"</span>
        case TypeASTERISK:<span class="cov0" title="0">
                return "*"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// String returns the string representation of a QClass
func (qc QClass) String() string <span class="cov8" title="1">{
        switch qc </span>{
        case ClassIN:<span class="cov8" title="1">
                return "IN"</span>
        case ClassCS:<span class="cov8" title="1">
                return "CS"</span>
        case ClassCH:<span class="cov8" title="1">
                return "CH"</span>
        case ClassHS:<span class="cov8" title="1">
                return "HS"</span>
        case ClassASTERISK:<span class="cov8" title="1">
                return "*"</span>
        default:<span class="cov8" title="1">
                return "UNKNOWN"</span>
        }
}

// Header bitfields according to RFC 1035 Section 4.1.1
type HeaderBitfield uint16

const (
        // QR - Query/Response bit
        HeaderQRQuery    HeaderBitfield = 0 &lt;&lt; 15 // Message is a query
        HeaderQRResponse HeaderBitfield = 1 &lt;&lt; 15 // Message is a response

        // OPCODE - Operation code
        HeaderOpcodeQuery  HeaderBitfield = 0 &lt;&lt; 11 // Standard query
        HeaderOpcodeIQuery HeaderBitfield = 1 &lt;&lt; 11 // Inverse query
        HeaderOpcodeStatus HeaderBitfield = 2 &lt;&lt; 11 // Server status request

        // Flags
        HeaderAA HeaderBitfield = 1 &lt;&lt; 10 // Authoritative Answer
        HeaderTC HeaderBitfield = 1 &lt;&lt; 9  // Truncation
        HeaderRD HeaderBitfield = 1 &lt;&lt; 8  // Recursion Desired
        HeaderRA HeaderBitfield = 1 &lt;&lt; 7  // Recursion Available
        HeaderZ  HeaderBitfield = 0 &lt;&lt; 4  // Reserved (must be zero)

        // RCODE - Response code
        HeaderRcodeOK   HeaderBitfield = 0 // No error
        HeaderRcodeFmt  HeaderBitfield = 1 // Format error
        HeaderRcodeSrvr HeaderBitfield = 2 // Server failure
        HeaderRcodeName HeaderBitfield = 3 // Name error
        HeaderRcodeNImpl HeaderBitfield = 4 // Not implemented
        HeaderRcodeRef  HeaderBitfield = 5 // Refused
)
</pre>
		
		<pre class="file" id="file6" style="display: none">// Package records provides implementations of various DNS record types
package records

import (
        "fmt"
        "net"

        "dklbreitling/goDNS/pkg/dns"
)

// ARecord represents an A (IPv4 address) record
type ARecord struct {
        Address net.IP
}

// NewARecord creates a new A record from an IPv4 address
func NewARecord(ip net.IP) (*ARecord, error) <span class="cov8" title="1">{
        if ip4 := ip.To4(); ip4 != nil </span><span class="cov8" title="1">{
                return &amp;ARecord{Address: ip4}, nil
        }</span>
        <span class="cov8" title="1">return nil, fmt.Errorf("invalid IPv4 address: %v", ip)</span>
}

// NewARecordFromString creates a new A record from a string representation
func NewARecordFromString(addr string) (*ARecord, error) <span class="cov8" title="1">{
        ip := net.ParseIP(addr)
        if ip == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid IP address: %s", addr)
        }</span>
        <span class="cov8" title="1">return NewARecord(ip)</span>
}

// Bytes returns the wire format representation of the A record
func (a *ARecord) Bytes() []byte <span class="cov8" title="1">{
        return a.Address.To4()
}</span>

// String returns the string representation of the A record
func (a *ARecord) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("ADDRESS: %s", a.Address.String())
}</span>

// Type returns the DNS record type
func (a *ARecord) Type() dns.QType <span class="cov8" title="1">{
        return dns.TypeA
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package records

import (
        "fmt"
        "net"

        "dklbreitling/goDNS/pkg/dns"
)

// AAAARecord represents an AAAA (IPv6 address) record
type AAAARecord struct {
        Address net.IP
}

// NewAAAARecord creates a new AAAA record from an IPv6 address
func NewAAAARecord(ip net.IP) (*AAAARecord, error) <span class="cov8" title="1">{
        if ip.To4() != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("IPv4 address provided for AAAA record: %v", ip)
        }</span>
        <span class="cov8" title="1">if ip.To16() == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid IPv6 address: %v", ip)
        }</span>
        <span class="cov8" title="1">return &amp;AAAARecord{Address: ip.To16()}, nil</span>
}

// NewAAAARecordFromString creates a new AAAA record from a string representation
func NewAAAARecordFromString(addr string) (*AAAARecord, error) <span class="cov0" title="0">{
        ip := net.ParseIP(addr)
        if ip == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid IP address: %s", addr)
        }</span>
        <span class="cov0" title="0">return NewAAAARecord(ip)</span>
}

// Bytes returns the wire format representation of the AAAA record
func (aaaa *AAAARecord) Bytes() []byte <span class="cov8" title="1">{
        return aaaa.Address.To16()
}</span>

// String returns the string representation of the AAAA record
func (aaaa *AAAARecord) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("ADDRESS: %s", aaaa.Address.String())
}</span>

// Type returns the DNS record type
func (aaaa *AAAARecord) Type() dns.QType <span class="cov8" title="1">{
        return dns.TypeAAAA
}</span>
</pre>
		
		<pre class="file" id="file8" style="display: none">package records

import (
        "fmt"

        "dklbreitling/goDNS/pkg/dns"
)

// GenericRecord represents a generic DNS record for unknown or unsupported types
type GenericRecord struct {
        RecordType dns.QType
        Data       []byte
}

// NewGenericRecord creates a new generic record
func NewGenericRecord(recordType dns.QType, data []byte) *GenericRecord <span class="cov0" title="0">{
        return &amp;GenericRecord{
                RecordType: recordType,
                Data:       make([]byte, len(data)), // Copy the data
        }
}</span>

// Bytes returns the wire format representation of the generic record
func (g *GenericRecord) Bytes() []byte <span class="cov0" title="0">{
        result := make([]byte, len(g.Data))
        copy(result, g.Data)
        return result
}</span>

// String returns the string representation of the generic record
func (g *GenericRecord) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("RDLength: %d\tRData: % 02X", len(g.Data), g.Data)
}</span>

// Type returns the DNS record type
func (g *GenericRecord) Type() dns.QType <span class="cov0" title="0">{
        return g.RecordType
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package records

import (
        "bytes"
        "fmt"

        "dklbreitling/goDNS/pkg/dns"
)

// NSRecord represents an NS (name server) record
type NSRecord struct {
        NameServer []dns.Label
}

// NewNSRecord creates a new NS record from domain labels
func NewNSRecord(nameserver []dns.Label) *NSRecord <span class="cov8" title="1">{
        return &amp;NSRecord{NameServer: nameserver}
}</span>

// NewNSRecordFromString creates a new NS record from a string
func NewNSRecordFromString(nameserver string) *NSRecord <span class="cov8" title="1">{
        return &amp;NSRecord{NameServer: dns.StringToLabels(nameserver)}
}</span>

// Bytes returns the wire format representation of the NS record
func (ns *NSRecord) Bytes() []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        for _, label := range ns.NameServer </span><span class="cov8" title="1">{
                buf.Write(label.ToBytes())
        }</span>
        <span class="cov8" title="1">return buf.Bytes()</span>
}

// String returns the string representation of the NS record
func (ns *NSRecord) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("NAME: %s", dns.LabelsToString(ns.NameServer))
}</span>

// Type returns the DNS record type
func (ns *NSRecord) Type() dns.QType <span class="cov8" title="1">{
        return dns.TypeNS
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
